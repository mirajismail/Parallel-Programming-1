# Question 4
For this question, I've created a Mandebrot set program with loop parallelization in the "make\_mandel\_map" 

```
    #pragma omp parallel for collapse(2)
    for (int i = 0; i < npix; i++) {
        for (int j = 0; j < npix; j++) {
            double x = ((double)i / (double)npix) * (xmax - xmin) + xmin;
            double y = ((double)j / (double)npix) * (ymax - ymin) + ymin;
            std::complex<double> a(x, y);
            mymap[i][j] = how_many_iter(a, maxiter);
        }
    }
```

The strong scaling script is available in mandelbrot\_stron\_scaling\_job.sh and the results are in scaling\_results.csv. It appears the program is most efficient at 2 threads.
